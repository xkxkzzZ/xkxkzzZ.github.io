<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>打工日记(1)</title>
      <link href="/2024/07/%E6%89%93%E5%B7%A5%E6%97%A5%E8%AE%B0(1)/"/>
      <url>/2024/07/%E6%89%93%E5%B7%A5%E6%97%A5%E8%AE%B0(1)/</url>
      
        <content type="html"><![CDATA[<ul><li><input checked="" disabled="" type="checkbox"> 喝茶</li><li><input checked="" disabled="" type="checkbox"> 找吃的</li><li><input checked="" disabled="" type="checkbox"> 困困</li><li><input checked="" disabled="" type="checkbox"> 装虚拟机</li><li><input checked="" disabled="" type="checkbox"> 被抓去聊天</li><li><input checked="" disabled="" type="checkbox"> 观摩检查路由器</li></ul><p>收获：公司主营装网络 搭网络（）AI向和硬件向排除，网络向上手快吃经验 学校学的没啥用，软件向未来方向是全栈 考虑多个立场的需求，不能只会修电脑&#x2F;写代码</p><p>目标：搬个小板凳.jpg</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git学习记录</title>
      <link href="/2024/07/git%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/07/git%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>学习网站：<a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a> </p><h5 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h5><p>向下添加一个版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><h5 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h5><p>添加分支  （指针还在当前分支）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;new-branch-name&gt;  </span><br></pre></td></tr></table></figure><p>切换分支（表示下一次commit的分支是这个）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch-name&gt;  </span><br></pre></td></tr></table></figure><p>创建新分支并切换到新分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;your-branch-name&gt;</span><br></pre></td></tr></table></figure><p>（较新的git可以用switch类似）</p><h5 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h5><p>把 指定分支 合并到 当前分支 里（把这两个节点作为parent，新建一个节点）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch-name&gt;  </span><br></pre></td></tr></table></figure><h5 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h5><p>把 当前分支bugFix rebase到 指定分支上 （指定分支作为当前分支的parent），复制的形式即原来分支不变，指定分支多了个儿子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase bugFix</span><br></pre></td></tr></table></figure><p>（把自己和自己这支的祖先都拉过来）</p><p>祖先rebase到孩子，就是直接拉下来</p><p>把main拉下来（这时main是bugFix的parent）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git rebase bugFix</span><br></pre></td></tr></table></figure><p>head默认指向当前分支如main 最后一次提交记录</p><p>checkout可以用来移动HEAD</p><p>可以用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout c1 </span><br></pre></td></tr></table></figure><p>让head指向c1 节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br></pre></td></tr></table></figure><p>git回到main*</p><p>提交记录通过哈希值标识</p><p>查看提交记录的哈希值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>相对引用</p><p>^ 向上移动一个提交记录</p><p>~ 向上移动多个提交记录 eg ~3</p><p>main^^是main的向上两个parent节点</p><p>如果main是一个合并提交，那么 <code>^&lt;num&gt; </code>可以选择第几个parent</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD^^</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD~4</span><br></pre></td></tr></table></figure><p>强制修改分支位置 git branch -f</p><p>将 main 分支强制指向 HEAD 的第 3 级 parent 提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -f main HEAD~3</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;某提交&gt;</span><br></pre></td></tr></table></figure><p>退回到某一个提交，直接退回 </p><p>eg</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD^</span><br></pre></td></tr></table></figure><p>远程仓库中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;要撤销的提交&gt;</span><br></pre></td></tr></table></figure><p>撤销当前提交，方式是添加和当前修改完全相反的修改作为儿子，使得新提交和上一个提交完全相同</p><p>eg</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick C2 C4</span><br></pre></td></tr></table></figure><p>把提交复制到当前位置   可以跟多个提交按照顺序抓过来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~4</span><br></pre></td></tr></table></figure><p>-i是interactive 可以整理前面的提交记录 调整顺序 删除等  然后复制到当前分支</p><p>想对之前某个提交记录做一些小调整</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 调整到最前面</span><br><span class="line">git commit --amend 进行小修改（生成并移动到当前提交记录的兄弟）</span><br><span class="line">git rebase -i 调整回去</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag V1 C1</span><br></pre></td></tr></table></figure><p>给C1增加tagV1，不指定为给HEAD加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git describe &lt;ref&gt;</span><br></pre></td></tr></table></figure><p>描述某提交记录的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</span><br></pre></td></tr></table></figure><p><code>tag</code> 表示的是离 <code>ref</code> 最近的标签， <code>numCommits</code> 是表示这个 <code>ref</code> 与 <code>tag</code> 相差有多少个提交记录， <code>hash</code> 表示的是你所给定的 <code>ref</code> 所表示的提交记录哈希值的前几位。当 <code>ref</code> 提交记录上有某个标签时，则只输出标签名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone</span><br></pre></td></tr></table></figure><p>在本地创建一个远程仓库的拷贝</p><p>远程分支 <code>&lt;remote name&gt;/&lt;branch name&gt;</code> eg 默认<code>origin/main</code></p><p>切换到远程分支commit 会进入HEAD分离状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure><p>从远程仓库获取数据（修改远程分支）</p><p>下载提交记录并更新远程分支指针 不会修改本地分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>先下载远程分支再合并到本地，相当于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch; git merge origin/main</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo搜索框</title>
      <link href="/2024/07/hexo%E6%90%9C%E7%B4%A2%E6%A1%86/"/>
      <url>/2024/07/hexo%E6%90%9C%E7%B4%A2%E6%A1%86/</url>
      
        <content type="html"><![CDATA[<p>下载拓展包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>添加search页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page search</span><br></pre></td></tr></table></figure><p><code>./themes/cactus/_config.yml</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nav:</span><br><span class="line">  search: /search/</span><br></pre></td></tr></table></figure><p>修改 <code>./source/search/index.md</code>文件头部 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: search</span><br><span class="line">type: search</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计网复习</title>
      <link href="/2024/06/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/"/>
      <url>/2024/06/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>面向往年卷的复习qwq</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>L5 应用层<br>L4 运输层<br>L3 网络层<br>L2 链路层<br>L1 物理层</p><p><strong>电路交换</strong>：在发送方和接收方之间建立一条专用的端到端链接（电路），预留了端系统间沿路径通信所需的资源<br><strong>分组交换</strong>：将长报文划分为较小的数据块（分组），不预留资源，以最大速率独立传输，但可能排队或丢包</p><p>网络<strong>时延</strong>主要由哪几部分组成？<br>处理时延、排队时延、传输时延、传播时延、（端到端时延）</p><p><strong>传输时延</strong>：分组长度 L &#x2F; 链路传输速率 R  （将所有的比特推向链路）<br><strong>传播时延</strong>：路由器距离 d &#x2F; 物理传播速率 s   （比特在链路上传播）</p><p>传输速率1M bps ： 每秒传输1M  bit &#x3D;  10^6 bit<br>1G bps &#x3D; 10^9 bit per second</p><p><strong>吞吐量</strong> &#x3D; 包长度 &#x2F; 总时长<br>总时长 &#x3D; 传输时延 + 2 * 传播时延 （停等）</p><p>检测<strong>碰撞时间</strong>：2*传播时延（最长路径）<br>CSMA&#x2F;CD：帧传输时间&gt;&#x3D; 往返延迟， <strong>最小帧长</strong>  &#x3D; 带宽 * 检测碰撞时间，要能检测出来</p><p><strong>协议分层的好处</strong>：网络协议分层的设计有多种好处：模块化设计、简化故障排除和调试、互操作性和标准化、灵活性和可扩展性、易于学习和理解、可管理性</p><p>互联网协议栈呈现出“<strong>沙漏</strong>”型的特点，即在传输层（特别是 TCP 和 UDP）部分变得很窄，而其他层次相对宽广。<br>好处：简化核心协议(TCP UDP)、灵活的应用层、统一的网络层、稳定和可靠、可扩展性、促进标准化</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>电子邮件中使用的应用层协议：SMTP</p><p><strong>HTTP 是如何体现 TCP “全双工” 特性的？</strong><br>HTTP 是应用层协议，它建立在传输层的TCP协议之上，而TCP协议本身具有全双工通信的特性。这意味着TCP连接可以在同一时间内支持双向数据传输，即客户端和服务器可以同时发送和接收数据。HTTP允许客户端向服务器发送请求，并允许服务器返回响应。这是通过TCP连接的全双工特性来实现的。</p><p><strong>HTTP方法：GET、POST、HEAD、PUT、DELETE</strong><br>GET：浏览器请求一个对象，在URL字段带有请求对象的标识<br>POST：用户向服务器请求一个与表单字段输入内容有关的Web页面，实体体中为输入值（例如用搜索引擎提供关键词）<br>HEAD：类似GET，会用HTTP报文响应，但不返回请求对象，用于调试<br>PUT：允许用户上传对象到指定的路径，用于向服务器上传对象<br>DELETE：删除web服务器上的对象</p><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP 头部</p><img src="/images/cnos复习/image-20240625204758273.png" style="zoom:40%;" /><p>ACK是等待的下一个序号 ，ACK &#x3D; Seq + Len<br>P161 eg Seq &#x3D; 92, Len &#x3D; 8, 92..99 共8字节，ACK &#x3D; 100<br>如果丢包停留在上次的ACK</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>客户端 –&gt; 服务器 SYN报文段，客户请求连接<br>服务器 —&gt; 客户 SYNACK报文段，服务器分配TCP缓存<br>客户 —&gt; 服务器 可以携带数据负载了</p><p>假设起始序号：客户42 服务器79<br>客户-&gt;服务器，序号Seq &#x3D; 42，确认号 ACK &#x3D; 79，data &#x3D; ‘C’<br>服务器 -&gt; 客户，Seq &#x3D; 79, ACK &#x3D; 43, data &#x3D; ‘C’<br>客户 -&gt; 服务器，Seq &#x3D; 43,  ACK &#x3D; 80，data &#x3D; 空 </p><h3 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h3><p>估计均值  EstimatedRTT &#x3D; (1-α) EstimatedRTT + α SampleRTT，α &#x3D; 1&#x2F;8<br>偏离程度  DevRTT &#x3D; (1-β) DevRTT + β SampleRTT，β &#x3D; 1&#x2F;4<br>TimeoutInterval&#x3D; EstimatedRTT + 4 DevRTT </p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>避免发送方使接收方缓存溢出，使发送方的发送速率和接收方的读取速率相匹配</p><p>rwnd：receive window 接收窗口<br>接收窗口不超过接收缓存   LastByteRcvd - LastByteRead &lt;&#x3D; RecvBuffer<br>rwnd表示接收方可用缓存空间   rwnd &#x3D; RecvBuffer - LastByteRcvd - LastByteRead<br>未确认数据不超过接收窗口  LastByteSent - LastByteAcked &lt;&#x3D; rwnd  </p><p>考虑发送方主机A ， 接收方主机B：<br>在B发送报文时将rwnd放在字段中，初始rwnd &#x3D; RecvBuffer（有数据或确认要发时才顺带发）<br>当rwnd &#x3D; 0 时，A继续发一个只有一个字节的报文段，这个报文段将被B确认，缓存开始清空，且确认报文中包含非0的rwnd</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>根据所感知到的网络拥塞程度来限制发送速率</p><p>MSS：Maximum Segment Size 最大报文段长度，一个 TCP 报文段中数据部分的最大字节数<br>cwnd：congestion window 拥塞窗口 每个RTT发的包的数量<br>ssthresh：慢启动阈值</p><p>3个冗余ACK：收到对相同数据的3个ACK，说明跟在这个已确认过3次的报文段之后的报文段丢失<br>超时：距离发送超过TimeoutInterval的事件，说明拥塞或丢失</p><p><strong>任何状态中</strong>：<br>超时： ssthresh &#x3D; cwnd &#x2F; 2，cwnd &#x3D; 1，进入慢启动<br>3个冗余ACK：ssthresh &#x3D; cwnd &#x2F; 2 ,  cwnd &#x3D; cwnd &#x2F; 2 + 3MSS，进入快速恢复</p><p><strong>慢启动：</strong><br>初始 cwnd &#x3D; 1 MSS<br>每次RTT：cwnd *&#x3D; 2<br>(对于每个new ACK， cwnd +&#x3D; MSS)<br>当cwnd &gt;&#x3D; ssthresh时，进入拥塞避免</p><p><strong>拥塞避免：</strong><br>每次RTT：cwnd +&#x3D; MSS<br>（对于每个new ACK，cwnd +&#x3D; MSS * (MSS &#x2F; cwnd)）</p><p><strong>快速恢复：</strong><br>收到新ACK：cwnd &#x3D; ssthresh ，进入拥塞避免<br>收到冗余ACK：cwnd +&#x3D; MSS</p><p><strong>TCP 协议与 UDP 协议的区别</strong><br>TCP：面向连接的运输，可靠的数据传输，头部开销大，有流量控制和拥塞机制，适合需要可靠数据传输的应用<br>UDP：无连接的运输，不可靠，头部开销小，应用对数据发送控制更精细，适合实时性要求高、能够容忍少量数据丢失的应用</p><h1 id="网络层：数据平面"><a href="#网络层：数据平面" class="headerlink" title="网络层：数据平面"></a>网络层：数据平面</h1><p><strong>网络层的功能</strong><br>转发：路由器从输入链路向输出链路转发数据报（数据平面）<br>路由选择：控制数据报沿着源主机到目的主机端到端路径中路由器之间的路由方式（控制平面）</p><p><strong>漏桶</strong>：数据包以固定速率进入“漏桶”，如果桶满了，多余的数据包会被丢弃或者排队等待。<br><strong>令牌桶</strong>：令牌桶中定期产生令牌，每个令牌代表一个可传输的数据包。数据包到达时需要获取令牌才能传输，如果没有令牌则被丢弃或排队等待。</p><h3 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h3><p>P221<br>a.b.c.d&#x2F;x ：高x位为前缀</p><p>掩码优点：转发时只需要考虑前缀，减少了在外部路由器中转发表的长度</p><p>12 30 6 -&gt; 14 32 8，因为每个子网要留一个网络地址和一个广播地址</p><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>P225<br>为一台新到的主机分配IP地址的租用，即插即用</p><p>服务器发现      主机广播，请求IP (srcip:0.0.0.0<br>服务器提供可能多个服务器广播，为其分配yiaddr<br>DHCP请求主机选一个服务器请求，有serverID<br>DHCP提供服务器提供IP DHCPACK</p><h3 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h3><p>P227<br>对外界使用同一个IP （默认网关）</p><p>主机10.0.0.1选择任意端口3345向LAN发送请求，NAT更新源IP 138.76.29.7 选择任意端口5001发出<br>收到响应后，根据端口号5001 在NAT转换表中检索出IP10.0.0.1和端口3345，重写IP和端口然后转发<br>NAT转换表：WAN：138.76.29.7, 5001，LAN：10.0.0.1, 3345</p><p>检测NET后的主机数量：看端口号</p><p>防火墙禁止web访问：封掉http的80端口和https的443端口</p><h4 id="IPv4-IPv6"><a href="#IPv4-IPv6" class="headerlink" title="IPv4, IPv6"></a>IPv4, IPv6</h4><p>以太网帧和ipv4首部如图：</p><img src="/images/cnos复习/image-20240624222955649.png" style="zoom:60%;" /><img src="/images/cnos复习/image-20240624223041041.png" style="zoom:33%;" /><p>Version 版本   4: IPv4 , 6: IPv6<br>HL (Header Length)  首部长度：以4字节为单位  不包括选项有20字节的首部HL&#x3D;5<br>Type of Service 服务类型<br>Total Length 总长度 包括首部和数据<br>ID(Identification)   标识<br>Protpcol 协议   6: TCP,  17:UDP<br>Header Checksum:  校验和，每次都要重新计算</p><p>在转发过程中，至少DestMAC   SourceMAC   TTL   Header Checksum会发生改变</p><p>IP 分片：<br>ID唯一标识不变<br>Flags :  为1 表示后续还有分片 为0 表示是最后一个分片<br>Fragment Offset: 单位是8字节，第一个分片为0 其余递增</p><p>eg若该IP 包表头长度&#x3D;28byte 编号 ID&#x3D;66且 length&#x3D;4000, 现经过一段最大传输单元MTU&#x3D;1500bytes的以太网，假设分段后的每个IP子包表头长28bytes，请写出每个子包的具体的Length， ID，分段标志fragment flag以及每段的偏移 offset</p><table><thead><tr><th></th><th>Total Length</th><th>ID</th><th>flag</th><th>offset（8bytes）</th></tr></thead><tbody><tr><td>1</td><td>1500 (28 + 1472)</td><td>66</td><td>1</td><td>0</td></tr><tr><td>2</td><td>1500 (28 + 1472)</td><td>66</td><td>1</td><td>184 (1472 &#x2F; 8)</td></tr><tr><td>3</td><td>1084 (28 + 1056)</td><td>66</td><td>0</td><td>368 (2944 &#x2F; 8)</td></tr></tbody></table><h1 id="网络层：控制平面"><a href="#网络层：控制平面" class="headerlink" title="网络层：控制平面"></a>网络层：控制平面</h1><p>AS：自治系统</p><h3 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><p>（AS内部）</p><p><strong>集中式：链路状态算法</strong> （LS）<br>dijkstra<br><strong>OSPF</strong> ：向所有路由器广播路由选择&#x2F; 链路状态变化信息</p><p><strong>分散式：距离向量算法</strong> （DV）<br>bellman-ford<br>对x，d(x, y) &#x3D; min { c(x, v) + d(c, y) }<br><strong>RIP</strong><br>无穷计数问题：毒性逆转，但复杂情况不行（不符合三角不等式的三角环）</p><p>对比<br>OSPF链路状态算法：需要整个网络的拓扑，收敛速度快，路由表中存储的是最短路径，内存带宽资源较大，较复杂，支持大型网络<br>RIP距离向量算法：只知道相邻节点的信息，逐步收敛，路由表中存储的是到目的网络的下一跳路由器及其距离，资源消耗较少，较简单，适合小型网络</p><h3 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h3><p>（AS之间）</p><p>eBGP：外部BGP，跨越两个AS<br>iBGP：内部BGP，相同AS之间<br>网关to网关，网关to全部</p><p>在一个 AS 内，路由器使用 iBGP 协议分发和更新内部路由信息。<br>当需要与其他 AS 通信时，边界路由器使用 eBGP 交换外部路由信息。<br>这些边界路由器将 eBGP 获取的外部路由信息通过 iBGP 传递给同一个 AS 内的其他路由器</p><p>AS-PATH ：路由路径，若路由器看到自己就停止通告，检测和避免环路<br>NEXT - HOP：AS-PATH 起始的路由器接口的IP地址</p><ol><li>具有最高本地偏好值的路由</li><li>具有最短AS - PATH的路由 （AS跳数而非路由器跳数）</li><li>具有最靠近NEXT-HOP路由器的路由</li></ol><h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p>请列出 ICMP 协议的至少两种用途<br>差错报告（目的网络&#x2F;主机&#x2F;协议&#x2F;端口不可达&#x2F;未知 TTL过期 IP头损坏），回显(ping)请求&#x2F;回答，抑制（拥塞控制），路由器通告&#x2F;发现</p><h1 id="链路层和局域网"><a href="#链路层和局域网" class="headerlink" title="链路层和局域网"></a>链路层和局域网</h1><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>用一个附加比特，<br>偶校验：使1的比特数为偶数，即亦或和为0<br>奇校验：使1的比特数为奇数，即亦或和为1</p><p>二维奇偶校验：可以检测和纠正单比特差错</p><h3 id="因特网检验和"><a href="#因特网检验和" class="headerlink" title="因特网检验和"></a>因特网检验和</h3><p>每16比特相加，最高位进位循环到最低位，最后取反码<br>接收方对所有数据包括检验和相加去反码，结果应该全1</p><h3 id="循环冗余校验CRC"><a href="#循环冗余校验CRC" class="headerlink" title="循环冗余校验CRC"></a>循环冗余校验CRC</h3><p>P300<br>发送方和接收方协商 r+1比特的生成多项式 G （最高位是1）<br>发送方选择r个附加比特R，并将它们附加到D上，这d+r比特用模2算数（XOR）应能被G整除，接收方用G去除接收到的d+r比特，能整除即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">G = 1001, D = 101110</span><br><span class="line">    101 011</span><br><span class="line"> ----------</span><br><span class="line">1001/101110 000</span><br><span class="line"> 1001</span><br><span class="line">   1010</span><br><span class="line">   1001</span><br><span class="line">     11 00</span><br><span class="line">     10 01</span><br><span class="line">      1 010</span><br><span class="line">      1 001</span><br><span class="line">        011</span><br><span class="line">R = 011</span><br></pre></td></tr></table></figure><p>三种常用L2层网络<strong>设备</strong>：交换机switch、集线器 hub、网桥bridge</p><p><strong>存储转发传输</strong>（Store-and-Forward）：数据在完整接收后才会被转发<br>直接转发（Cut-Through）</p><h3 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h3><p>P304</p><p>所有节点同步传输（在每帧开始时传输），空闲则传输，碰撞以概率p重传<br>给定节点传输成功概率 p(1-p)^N-1，任一节点传输成功概率 Np(1-p)^N-1<br>达到最大效率：d Np(1-p)^N-1 &#x2F; dp N个节点 p &#x3D; 1&#x2F;N 时效率最大 </p><p>区别于纯ALOHA：节点不同步帧</p><p><strong>CSMA&#x2F;CD</strong>：具有碰撞检测的(CD)  载波侦听多路访问(CSMA)  P308<br>侦听到信道空闲才发送数据，检测到碰撞停止发送，等待随机量重新尝试</p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>P324<br>有mac - port表，自学习，根据发来的包学习来的mac对应的接口<br>没有表项，发向除来的端口外的全部端口；发给自己，丢掉；发给已知mac，直接转发</p><p>如果存在环路，会出现广播风暴问题，因此需要限制拓扑结构为生成树，有生成树协议 STP（Spanning Tree Protocol）<br>（拓展：MC-LAG：通过将多个物理链路捆绑成一个逻辑链路来增加带宽和冗余）</p><p><strong>和路由器对比</strong><br>交换机属于第二层链路层，用MAC转发，即插即用，限制拓扑为生成树，有较高的分组过滤和转发速率<br>路由器属于第三层网络层，用IP转发，需要人为配置ip，丰富的拓扑结构，处理时间较长</p><h1 id="无线网络与移动网络"><a href="#无线网络与移动网络" class="headerlink" title="无线网络与移动网络"></a>无线网络与移动网络</h1><p>与有线网络相比，无线网络的信道有哪些额外的特性？P351<br>递减的信号强度（路径损耗）、来自其他源的干扰、多路径传播</p><p>什么是无线网络的隐蔽终端问题？请给出一种缓解隐蔽终端问题的常用方法。P352, P361<br>隐蔽终端问题：两站点的传输会在目的地发生干扰，环境的物理阻挡或信号的衰减使得不能互相听到<br>使用请求发送RTS和允许发送CTS控制帧来预约对信道的访问，发送方先发一个RTS表明传输时间，AP收到后广播一个CTS，许可其发送并阻止其他站点发送</p><p><strong>CSMA&#x2F;CA</strong>：带碰撞避免的(CA) 载波侦听多路访问(CSMA)  P359<br>监听到信道空闲，在一个分布式帧间间隔DIFS后发送，否则选取随机回退值 闲时递减，<br>目的站点收到一个通过CRC校验的帧后，在一个短帧间间隔SIFS后发一个确认帧<br>发送方收到确认（802.11有链路层确认ARQ），否则回退重传</p><p>CSMA&#x2F;CD 协议与 CSMA&#x2F;CA 协议的区别是什么？<br>CD碰撞检测，CA(802.11)碰撞避免；CA(802.11)有链路层确认&#x2F;重传</p><p>为什么CSMA&#x2F;CD 不适用于无线网络？<br>碰撞检测要求站点具有同时发送（站点自己的信号）和接收（检测其他站点是否也在发送）的能力。在802.11适配器上，接收信号的强度通常远小于发送信号的强度，构建具有检测碰撞能力的硬件代价较大。<br>即使适配器可以同时发送和监听信号（并且假设一听到信道忙就放弃发送），适配器也会由于隐藏终端问题和衰减问题而无法检测到所有的碰撞</p><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><p>非对称加密算法：RSA，一方有公钥私钥<br>对称加密算法：AES，各自有相同的密钥用于加密和解密，保管密钥困难</p><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>两个大素数p, q<br>n &#x3D; pq,  z &#x3D; (p-1)(q-1)<br>找e（e&lt;n且与z互素<br>找d（ed mod z &#x3D; 1<br>公钥(n, e)  私钥(n, d)</p><p>报文m，密文c<br>加密 c &#x3D; m ^ e mod n<br>解密 m &#x3D; c ^ d mod n</p><h3 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h3><p>哈希函数：<br>发送方，计算数据的哈希值，并与数据一起发送<br>接收方，收到数据后重新计算数据的哈希值，与发送方提供的哈希值进行比较</p><p>Alice和Bob共享秘密s<br>A：报文m，计算H(m+s)，附到报文上发送 (m, H(m+s))<br>B：收到 (m, h)，计算H(m+s)，和h进行比较</p><h3 id="可认证性：数字签名"><a href="#可认证性：数字签名" class="headerlink" title="可认证性：数字签名"></a>可认证性：数字签名</h3><p>发送方用私钥对报文（或更短的H(m)）进行加密<br>接收方用公钥解密，验证数字签名</p><p>认证中心CA：将公钥与特定实体绑定，发行证书</p><p><strong>支持学生在异地通过 Internet 进入学校网络访问学术资源的技术及其原理</strong><br>要实现异地访问学校网络的需求，可以使用<strong>虚拟专用网络（VPN）</strong>技术。</p><p>VPN (Virtual Private Network) 通过在公共网络（如 Internet）上创建一个加密的隧道，使得远程用户可以安全地访问学校内部网络资源。其主要工作原理包括：</p><ol><li><strong>VPN 客户端和服务器：</strong> 学生的设备上需要安装 VPN 客户端软件，该软件与学校网络的 VPN 服务器进行通信。</li><li><strong>加密和认证：</strong> VPN 连接使用加密技术（如 SSL&#x2F;TLS 或 IPSec）确保传输数据的安全性，同时通过认证机制（如用户名&#x2F;密码、数字证书）验证用户身份。</li><li><strong>隧道协议：</strong> VPN 使用隧道协议（如 PPTP、L2TP、OpenVPN）将数据包封装起来，使其在 Internet 上传输时保持隐私。</li><li><strong>解封装和解密：</strong> VPN 服务器接收到加密的数据包后，解封装并解密，然后将其转发到学校内网，用户即可访问内部资源。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统os复习</title>
      <link href="/2024/06/os%E5%A4%8D%E4%B9%A0/"/>
      <url>/2024/06/os%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>面向往年卷的复习qwq</p></blockquote><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h4 id="进程树-运行结果"><a href="#进程树-运行结果" class="headerlink" title="进程树 &amp; 运行结果"></a>进程树 &amp; 运行结果</h4><h5 id="eg1"><a href="#eg1" class="headerlink" title="eg1"></a>eg1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fd = open(&quot;data.txt, 0_RDONLY&quot;)  //data.txt:&quot;abcdefghijklmnopqrst&quot;</span><br><span class="line">fork();</span><br><span class="line">fork();</span><br><span class="line">read(fd, &amp;buffer, 2);</span><br><span class="line">printf(&quot;%d, %s\n&quot;, getpid(), buffer);</span><br></pre></td></tr></table></figure><p>代码运行过程中，共产生4个进程，进程树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1(shell)</span><br><span class="line">2</span><br><span class="line"> 3   4</span><br><span class="line"> 5</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2, ab</span><br><span class="line">3, cd</span><br><span class="line">4, ef</span><br><span class="line">5, gh</span><br></pre></td></tr></table></figure><h5 id="eg2"><a href="#eg2" class="headerlink" title="eg2"></a>eg2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i</span><br><span class="line">for (i=0; i&lt;4; i++)</span><br><span class="line">if (fork() == 0) break;</span><br><span class="line">printf(&quot;%d-%d: %d\n&quot;, getpid(), getppid(), i)</span><br></pre></td></tr></table></figure><p>代码运行时，创建了5个进程，进程树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1000(shell)</span><br><span class="line">1001</span><br><span class="line">1002 1003 1004 1005</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1001-1000: 4</span><br><span class="line">1002-1001: 0</span><br><span class="line">1003-1001: 1</span><br><span class="line">1004-1001: 2</span><br><span class="line">1005-1001: 3</span><br></pre></td></tr></table></figure><h5 id="eg3"><a href="#eg3" class="headerlink" title="eg3"></a>eg3</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int count = 0</span><br><span class="line">for (int i=0; i&lt;2; i++)</span><br><span class="line">if (fork() &gt; 0) break;</span><br><span class="line">for (int j=0; i&lt;20; j++)</span><br><span class="line">count++</span><br><span class="line">printf(&quot;Count: %d\n&quot;, count);</span><br></pre></td></tr></table></figure><p>代码运行过程中创建了3个进程，进程树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1(shell)</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>执行结果：都是Count: 20，因为每个进程相互独立，count 计数器在各自进程的栈空间中，互不干扰</p><h5 id="eg4"><a href="#eg4" class="headerlink" title="eg4"></a>eg4</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int count = 0</span><br><span class="line">count += fork();</span><br><span class="line">count += fork();</span><br><span class="line">count += fork();</span><br><span class="line">printf(&quot;%d-%d: %d\n&quot;, getpid(), getppid(), count);</span><br></pre></td></tr></table></figure><p>进程树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  0(shell)</span><br><span class="line">1</span><br><span class="line">234</span><br><span class="line"> 5  6  7</span><br><span class="line"> 8</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1: 0 +2+3+49</span><br><span class="line">2: 0 +0+5+611</span><br><span class="line">3: 2 +0+79</span><br><span class="line">4: 5 +05</span><br><span class="line">5: 0 +0+88</span><br><span class="line">6: 5 +05</span><br><span class="line">7: 2 +02</span><br><span class="line">8: 0 +00</span><br></pre></td></tr></table></figure><p>结果不唯一，因为父子进程调度执行的先后顺序不定，例如长子进程可能在次子进程之后执行 fork 系统调用；不同进程执行 printf 的先后顺序不定；</p><h4 id="管道通信机制"><a href="#管道通信机制" class="headerlink" title="管道通信机制"></a>管道通信机制</h4><p>可用于具有亲缘关系的进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信，由shell进程创建。</p><p>cat，拼接指定的若干个文件的内容并输出到标准输出设备</p><p>sort，排序指定文件或标准输入设备文件的内容，默认升序排序</p><h5 id="eg1-1"><a href="#eg1-1" class="headerlink" title="eg1"></a>eg1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 file2 | sort</span><br></pre></td></tr></table></figure><p>执行结果：1 2 3 4 5 6 7 8</p><p>命令执行过程中，系统产生了两个兄弟关系的子进程：<br>一个用来执行 <code>cat file1 file2</code> ，并把输出重定向到管道<br>一个执行 <code>sort</code> ，其输入重定向到管道</p><h5 id="eg2-1"><a href="#eg2-1" class="headerlink" title="eg2"></a>eg2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat fileA.txt fileB.txt | sort &gt; sorted.txt</span><br></pre></td></tr></table></figure><p>执行结果：输出一个文件 sorted.txt 文件，文件中的内容为 1 2 3 4 5 6 7 8</p><p>命令执行过程中，会创建2个进程，都是 shell 的子进程<br>cat 进程输出重定向到管道，sort 进程输入重定向到管道，输出重定向到 sorted.txt 文件</p><h5 id="其他进程间通信机制"><a href="#其他进程间通信机制" class="headerlink" title="其他进程间通信机制"></a>其他进程间通信机制</h5><p>信号机制、消息队列、共享内存、套接字</p><h4 id="API函数与系统调用"><a href="#API函数与系统调用" class="headerlink" title="API函数与系统调用"></a>API函数与系统调用</h4><p><strong>系统调用</strong>：是操作系统提供给用户访问内核空间的特殊接口，其对应的服务例程属于系统程序，在内核态运行；</p><p><strong>API 函数</strong>：是应用程序接口，为应用程序开发者提供便携的功能支持。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fork(), getpid(), getppid(), wait(), sleep()</span><br><span class="line">printf(), (setbuf())</span><br></pre></td></tr></table></figure><p><strong>区别</strong>：系统调用必然访问内核态，而 API 函数强调的是如何通过接口来获得所需服务，部分 API 函数可以在用户态运行。</p><p><strong>联系</strong>：一个 API 函数根据是否需要访问内核态，可能不需要或需要一至多个系统调用来实现特定功能。</p><p><strong>如果不使用上述 API 函数，是否能直接进行相关系统调用？如果可以，试讨论这样做的弊端</strong><br>可以，但代码复杂度增加，可读性差；需要关注不同硬件平台、不同操作系统之间的差异，可移植性差</p><h4 id="叙述过程"><a href="#叙述过程" class="headerlink" title="叙述过程"></a>叙述过程</h4><h5 id="简要叙述open系统调用的工作过程（当前工作目录是-user-os）"><a href="#简要叙述open系统调用的工作过程（当前工作目录是-user-os）" class="headerlink" title="简要叙述open系统调用的工作过程（当前工作目录是&#x2F;user&#x2F;os）"></a>简要叙述open系统调用的工作过程（当前工作目录是&#x2F;user&#x2F;os）</h5><ol><li>读取根目录，找user对应的文件控制块（inode）</li><li>读取user内容，找到os对应的inode</li><li>读取os内容，找到data.txt对应的inode</li><li>判断访问控制权限，创建活动inode，创建系统已打开文件表项，创建用户打开文件表项</li></ol><h5 id="简要描述-fork-的实现"><a href="#简要描述-fork-的实现" class="headerlink" title="简要描述 fork 的实现"></a>简要描述 fork 的实现</h5><p>通过系统调用陷入内核态，寻找空闲 PCB 初始化，为子进程分配新空间并复制父进程内容，父进程返回子进程 pid，子进程返回 0，创建失败返回负数。</p><h5 id="简要描述管道通信机制的实现"><a href="#简要描述管道通信机制的实现" class="headerlink" title="简要描述管道通信机制的实现"></a>简要描述管道通信机制的实现</h5><p>（父进程向子进程发送数据：）</p><ol><li>使用 <code>pipe</code> 系统调用创建一个管道，得到两个文件描述符：一个用于读（读端），一个用于写（写端）</li><li>使用 <code>fork</code> 系统调用创建子进程。父进程和子进程会共享相同的管道文件描述符。</li><li>子进程关闭管道的写端，并将管道的读端重定向到标准输入。父进程关闭管道的读端，并将管道的写端重定向到标准输出。</li><li>父进程写入数据到管道，子进程从管道中读取数据，实现数据传输。</li><li>数据传输完成后，关闭管道的文件描述符。</li></ol><h5 id="简要描述输入输出重定向机制的实现"><a href="#简要描述输入输出重定向机制的实现" class="headerlink" title="简要描述输入输出重定向机制的实现"></a>简要描述输入输出重定向机制的实现</h5><p>dup2()：用于复制文件描述符，可以将一个已打开的文件描述符复制到另一个文件描述符。<br>open()：用于打开文件并返回文件描述符。<br>close()：用于关闭文件描述符。</p><ol><li><p>使用 <code>open</code> 系统调用打开目标文件或设备，获取一个文件描述符。</p></li><li><p>使用 <code>close</code> 系统调用关闭标准输入（文件描述符 0）、标准输出（文件描述符 1）或标准错误（文件描述符 2），这取决于重定向的类型。</p></li><li><p>使用 <code>dup</code> 或 <code>dup2</code> 系统调用，将目标文件描述符复制到标准文件描述符的位置。</p></li><li><p>当标准文件描述符被重定向后，进程对标准输入、输出或错误的操作就会转向目标文件或设备。</p></li></ol><p>输入重定向：使用 <code>dup2(fd, 1)</code> 将目标文件描述符 <code>fd</code> 复制到标准输出（文件描述符 1）。使得所有标准输出的数据都写入到指定的文件或设备中。</p><p>输出重定向：使用 <code>dup2(fd, 0)</code> 将目标文件描述符 <code>fd</code> 复制到标准输出（文件描述符 0）。使得程序从指定的文件或设备读取输入数据。</p><h5 id="简述sleep工作过程"><a href="#简述sleep工作过程" class="headerlink" title="简述sleep工作过程"></a>简述sleep工作过程</h5><p>操作系统内核将调用 sleep 的进程从运行态转为等待态，利用时钟中断在达到指定时间后，将进程从等待态转到就绪态。</p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h4 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h4><p>先来先服务(FCFS)、最短作业优先(SJF)、（最高相应比优先）</p><p>具有<strong>两道</strong>作业的批处理系统：最多只能有两个作业同时进行</p><h5 id="平均周转时间-Avg-结束时间-就绪时间"><a href="#平均周转时间-Avg-结束时间-就绪时间" class="headerlink" title="平均周转时间 &#x3D; Avg {结束时间 - 就绪时间}"></a>平均周转时间 &#x3D; Avg {结束时间 - 就绪时间}</h5><h5 id="平均带权周转时间-Avg-（结束时间-就绪时间）-估计运行时间"><a href="#平均带权周转时间-Avg-（结束时间-就绪时间）-估计运行时间" class="headerlink" title="平均带权周转时间 &#x3D; Avg {  （结束时间 - 就绪时间） &#x2F; 估计运行时间 }"></a>平均带权周转时间 &#x3D; Avg {  （结束时间 - 就绪时间） &#x2F; 估计运行时间 }</h5><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>时间片轮转、优先级调度（、先来先服务、多级反馈队列、最高响应比）</p><p> 进程调度算法往往需要平衡 IO 密集型和计算密集型进程占用 CPU 的时间，设计此类算法最关键的问题是什么（请结合课上介绍的某个具体的算法进行讨论）？</p><p>最关键问题是<strong>预测</strong>进程的行为。例如<strong>老化算法</strong>，可根据进程历史行为来预测其后续行为</p><p><strong>抢占式</strong>：优点：不会使得一个低优先级进程长时间占用 CPU，更好响应优先级高的进程；缺点：进行进程调度浪费太多时间 </p><p><strong>非抢占式</strong>：优点：进程调度少，CPU 利用率高；缺点：可能会使一个低优先级进程霸占 CPU，紧急的进程不能响应</p><p>简要讨论批处理系统和分时系统的区别</p><p><strong>批处理系统</strong>：用户脱机工作、成批处理作业、多道程序运行(早期为单道程序运行)、 作业周转时间长。</p><p><strong>分时系统</strong>：同时性，多个用户同时；独立性，每个用户相对独立；及时性，快速响应用户请求；交互性，用户联机工作</p><p><strong>死锁产生的必要条件</strong>有哪些？互斥条件、占有并等待条件、不剥夺条件、循环等待条件</p><p>设备采用静态分配策略破坏了哪个条件？破坏了占有并等待条件 （下面）</p><h4 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h4><p>可变分区、伙伴算法(Buddy) （、固定分区）</p><p>伙伴算法(Buddy) ：将用户内存区域对半分割，以实现最佳适应的分配，需要时对半分割，不需要时合并</p><p>仅存在“外碎片” ：可变分区、伙伴系统分配（？）<br>既存在“外碎片”又存在“内碎片”： 固定分区、分页</p><h5 id="可变分区主存分配算法"><a href="#可变分区主存分配算法" class="headerlink" title="可变分区主存分配算法"></a>可变分区主存分配算法</h5><p>最先适配：起始地址从小到大，第一个满足</p><p>下次适配：从上次扫描结束的位置，第一个满足</p><p>最优适配：分区大小从小到大，第一个满足</p><p>最坏适配：分区大小从大到小，第一个满足</p><p>某时刻在内存中有三个空闲区，其首地址和大小分别是：空闲区 1（100KB，10KB），空闲区 2（200KB，20KB），空闲区 3（300KB，15KB），画出该时刻内存分布图 ； </p><p>​    <img src="/images/cnos复习/image-20240627234816668.png" alt="image-20240627234816668" style="zoom: 40%;" /></p><h4 id="外围设备"><a href="#外围设备" class="headerlink" title="外围设备"></a>外围设备</h4><p>静态分配，SPOOLing</p><p>SPOOLing：将任务（如打印任务）先存储到磁盘或其他存储设备中，而不是立即向外围设备发送。这样做可以让操作系统管理和调度多个任务，以便在外围设备空闲时执行。这样预输入和缓输出时间与其他任务重迭进行。</p><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p><strong>当前系统状态是否安全</strong>（银行家算法）？安全，存在<strong>安全序列</strong> P0-P4-P3-P2-P1</p><p>Need &#x3D; Max - Allocation，Available &gt; Need 时可以分配，并回收 Available +&#x3D; Allocation</p><p><strong>能否满足 P1 的资源申请</strong>（分配拒绝法）？不能，满足 P1 的请求之后不存在安全序列。 &#x2F; 能，满足该请求后，系统状态仍是安全的。</p><p>先分配，更新 Available 和 Need，再检查是否安全</p><p>修改资源分配后，系统中<strong>是否有死锁发生</strong>，涉及了哪些进程？发生了死锁，涉及进程 P0,P1,P2,P3</p><p>尝试满足进程当前的需求即可，满足可回收，如果都不满足就死锁</p><p><strong>银行家算法</strong>：如果系统现存的各类资源能满足其最大需求量时，就满足申请</p><p>银行家算法在实际应用中存在哪些困难？难以实现，一方面很难知道每个进程需要的资源最大数，另一方面系统中进程的数量是动态变化的 （死锁检测算法可以实现）</p><p><strong>Warshell传递闭包</strong> 检测死锁：有依赖关系连边，传递闭包，如果存在自己指向自己的边说明出现死锁</p><p>程序中互斥信号量PV，产生的线程间死锁：发生的概率极小；操作系统不能检测出此类死锁，不是操作系统管辖的资源</p><p>在 n 个进程共享 m 个资源的系统中，且所有最大需求量之和小于 m+n，则该系统不会产生死锁：考虑极端情况每个进程都申请x-1个资源，等一个资源，此时用掉的资源小于m，还有至少一个资源没有被分配，可以给一个进程做完之后释放更多的资源满足全部需求，不存在死锁</p><h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p>1KB &#x3D; 2^10 B,  1MB &#x3D; 2^20 B,  1GB &#x3D; 2^30 B</p><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><p>页表最大包含多少个页表项？单个页表的页表项的理论最大是多少？</p><h5 id="逻辑-理论-最大页数-总地址空间2-32-B-页面大小-（页表相关）"><a href="#逻辑-理论-最大页数-总地址空间2-32-B-页面大小-（页表相关）" class="headerlink" title="逻辑(理论)最大页数 &#x3D; 总地址空间2^32 B &#x2F; 页面大小   （页表相关）"></a>逻辑(理论)最大页数 &#x3D; 总地址空间2^32 B &#x2F; 页面大小   （页表相关）</h5><p>一个进程页表的理论最大尺寸是多少字节？</p><p>页表尺寸 &#x3D;  页表项大小4B * 页面数  </p><p>页框号（假设从 0 开始编号）的 最大值是多少？反置页表最多包含多少页表项？</p><h5 id="物理-实际-最大页数-物理内存-页面大小（页框相关）"><a href="#物理-实际-最大页数-物理内存-页面大小（页框相关）" class="headerlink" title="物理(实际)最大页数 &#x3D; 物理内存 &#x2F; 页面大小（页框相关）"></a>物理(实际)最大页数 &#x3D; 物理内存 &#x2F; 页面大小（页框相关）</h5><h5 id="逻辑地址划分"><a href="#逻辑地址划分" class="headerlink" title="逻辑地址划分"></a>逻辑地址划分</h5><p>页目录号、页号、页内偏移：页目录位移，页表页位移，页内位移</p><p>页目录表 – 页表页 ，其中页目录表大小可变，页表页大小为一个页面大小</p><p>由页面大小算页内位移，页面大小 &#x2F; 页表项大小(4B) 算页号，其余为页目录号</p><h5 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h5><p>根据进程标识符和页号检索页表</p><p>优点：节约内存，只需为所有进程维护一张表。 </p><p>缺点：地址转换效率低。仅包含调入内存的页面，不包含未调入的页面，仍需要为进程建立传统页表，存放在磁盘上，发生缺页异常时需要多访问一次磁盘，速度会比较慢。（？）</p><h5 id="页面号-逻辑地址-页面大小-（从0开始，向下取整）"><a href="#页面号-逻辑地址-页面大小-（从0开始，向下取整）" class="headerlink" title="页面号 &#x3D; 逻辑地址&#x2F;页面大小 （从0开始，向下取整）"></a>页面号 &#x3D; 逻辑地址&#x2F;页面大小 （从0开始，向下取整）</h5><p>逻辑地址访问序列 对应的页面访问序列？</p><p>执行指令中 逻辑地址访问哪些页面？（访问当前指令所在页面，和目标地址页面，一般目标地址会引发缺页异常）</p><h5 id="逻辑地址到物理地址"><a href="#逻辑地址到物理地址" class="headerlink" title="逻辑地址到物理地址"></a>逻辑地址到物理地址</h5><p>逻辑地址 &#x3D; 页号 * 页大小 + 页内偏移</p><p>物理地址 &#x3D; 页框号*页大小 + 页内偏移</p><p>接下来要访问的逻辑地址为 7001，给出对应的物理地址？</p><p>页大小4KB，页号 &#x3D; 1，页框号10，偏移2905，物理地址10*4096+2905 &#x3D; 43865</p><h5 id="最佳页面尺寸"><a href="#最佳页面尺寸" class="headerlink" title="最佳页面尺寸"></a>最佳页面尺寸</h5><p><img src="/images/cnos%E5%A4%8D%E4%B9%A0/image-20240706172320072.png" alt="image-20240706172320072"></p><p>s 是进程平均占用的内存大小，e是页表项的大小，p 是页面大小</p><p>假如统计结果表明进程平均占用 8MB 左右的内存空间，页面大小设为 4KB 是 否合理（给出分析过程）？<br>s &#x3D; 8MB, e &#x3D; 4B，由 p^2 &#x3D; 2se，得 p &#x3D; 8KB，因此不合理</p><p>页面大小为 1KB，页表项大小为 4B。假设题中页面大小的设置是合理的，则可大致可推断出该系统中运行的进程平均占用内存大小为多少？（给出计算过程）<br>p &#x3D; 1KB, e &#x3D; 4B, 求s，由 p^2 &#x3D; 2se，解得 s &#x3D; 128KB</p><h4 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h4><h5 id="在支持请求分页的系统中，一个页表项一般要包含哪些信息？"><a href="#在支持请求分页的系统中，一个页表项一般要包含哪些信息？" class="headerlink" title="在支持请求分页的系统中，一个页表项一般要包含哪些信息？"></a>在支持请求分页的系统中，一个页表项一般要包含哪些信息？</h5><p>页框号：指示页面在物理内存中的位置，用于将逻辑地址转换为物理地址。</p><p>访问位&#x2F;引用位 R：记录页面是否被访问过。</p><p>修改位&#x2F;脏位 W：记录页面是否被修改过，用于在页面换出时确定是否需要将页面写回到磁盘。</p><p>锁定位：指示页面是否被锁定在内存中，防止其被换出。某些关键页面或实时系统的页面需要锁定在内存中以确保系统的稳定性和实时性。</p><p>缺页（驻留）标志：指示页面是否在物理内存中。如果页面在内存中，则该位为1；如果页面不在内存中且需要从磁盘调入，则该位为0。当缺页中断发生时，该位被检查以确定是否需要将页面从磁盘调入内存。</p><p>针对上述一条指令执行可能引发多次缺页中断的情况，试着给出一种软硬件配合的机制用于尽量减少缺页中断发生的情况（提示：锁定位）</p><p>硬件解释 CALL 指令过程中，先期将已在内存中指令涉及的页面对应的页表项锁定位置 1，当操作系统内核页面替换算法执行时，避免淘汰锁定位为 1 的页面，从而减少缺页发生的次数。</p><p>操作系统会借助时钟中断定期清零 R 位，以获得页面引用信息</p><p>某页表项，其访问位是 0，修改位是 1？该页面之前被修改过，尚未写回磁盘，故修改位为 1。引用位在修改发生后经历至少一次操作内核的清零操作。</p><p>什么原因导致图中 3 号页面的 W 位从 t1 时刻的 1 变为 t2 时刻的 0？3 号页面被写回了磁盘</p><p>操作系统至少间隔多长时间（逻辑时钟）对访问位进行清零操作？（当前时钟164，最近访问时间-访问位：160-0, 161-0, 162-1, 163-1）至少间隔 164-161 &#x3D; 3 个逻辑时钟</p><h5 id="简要讨论多级页表机制的优缺点"><a href="#简要讨论多级页表机制的优缺点" class="headerlink" title="简要讨论多级页表机制的优缺点"></a>简要讨论多级页表机制的优缺点</h5><p>优点：页表不需要连续存储在内存中，使得未使用的页面对应的页表项可不占内存空间，减少内存使用<br>缺点：增加地址转换的时间开销（多次访问内存）</p><h5 id="请求分页存储管理技术往往会增加含地址指令的执行时间开销，试分析增加的时间开销主要有哪些？如何应对？"><a href="#请求分页存储管理技术往往会增加含地址指令的执行时间开销，试分析增加的时间开销主要有哪些？如何应对？" class="headerlink" title="请求分页存储管理技术往往会增加含地址指令的执行时间开销，试分析增加的时间开销主要有哪些？如何应对？"></a>请求分页存储管理技术往往会增加含地址指令的执行时间开销，试分析增加的时间开销主要有哪些？如何应对？</h5><p>查询内存页表的开销：利用硬件提供的相联存储器来缓存部分常用页表项，减少内存页表查询次数</p><p>缺页引发的页面导入和导出的开销：设计更为合理的页面替换算法，减少缺页发生的次数。</p><p>（页表项过多占用空间大：采用多级页表；访问速度慢：用快表）</p><p>为了避免频繁缺页引发“颠簸”，系统中同时运行的进程需要满足什么条件？</p><p>内存中工作集总尺寸不能超过 1GB（即物理内存大小）</p><h4 id="页面替换算法"><a href="#页面替换算法" class="headerlink" title="页面替换算法"></a>页面替换算法</h4><p>先进先出、时钟页面、最近不使用</p><h5 id="先进先出页面替换算法（FIFO）-First-In-First-Out"><a href="#先进先出页面替换算法（FIFO）-First-In-First-Out" class="headerlink" title="先进先出页面替换算法（FIFO） First In First Out"></a>先进先出页面替换算法（FIFO） First In First Out</h5><p>保持一个队列，按页面进入内存的时间顺序排列。<br>当需要替换页面时，选择队列中最早进入内存的页面（即队首页面）进行替换。<br>被替换的页面出队，新页面入队。</p><h5 id="第二次机会页面替换算法-Second-Chance"><a href="#第二次机会页面替换算法-Second-Chance" class="headerlink" title="第二次机会页面替换算法  Second Chance"></a>第二次机会页面替换算法  Second Chance</h5><p>保持一个队列，与FIFO类似，但在替换页面之前，检查页面的访问位（通常是R位，表示最近是否被访问过）。<br>如果队首页面的访问位为1，则将其访问位清0，并将该页面移到队尾，给它一个“第二次机会”。<br>如果队首页面的访问位为0，则直接替换该页面。</p><h5 id="时钟页面替换算法"><a href="#时钟页面替换算法" class="headerlink" title="时钟页面替换算法"></a>时钟页面替换算法</h5><p>是第二次机会算法的变种，通过一个环形队列（模拟时钟的表盘）来组织页面。<br>页面按顺序排列成环，使用一个指针（类似时钟的指针）指向待替换页面。<br>当需要替换页面时，检查指针指向页面的访问位：若访问位为0，则替换该页面。若访问位为1，则将其访问位清0，指针移到下一个页面，继续检查。</p><h5 id="最近最少用页面替换算法-LRU-Least-Recently-Used"><a href="#最近最少用页面替换算法-LRU-Least-Recently-Used" class="headerlink" title="最近最少用页面替换算法(LRU) Least Recently Used"></a>最近最少用页面替换算法(LRU) Least Recently Used</h5><p>记录每个页面最后一次被访问的时间。<br>总是淘汰在最近一段时间里较久未被访问的页面。<br>维护一个页面淘汰队列，队尾总是指向最近访问的页面，队头是最近最少使用的页面。</p><h5 id="最近没有使用页面替换算法-NRU-Not-Recently-Used"><a href="#最近没有使用页面替换算法-NRU-Not-Recently-Used" class="headerlink" title="最近没有使用页面替换算法(NRU) Not Recently Used"></a>最近没有使用页面替换算法(NRU) Not Recently Used</h5><p>根据引用位 R 和修改位 M 的组合来进行页面替换。<br>（先看引用位再看修改位）替换优先级从低到高为 (R, M):   (0, 0) -&gt; (0, 1) -&gt; (1, 0) -&gt; (1, 1)，</p><h5 id="最不常用页面替换算法-LFU"><a href="#最不常用页面替换算法-LFU" class="headerlink" title="最不常用页面替换算法(LFU)"></a>最不常用页面替换算法(LFU)</h5><p>记录每个页面的访问次数。当需要替换页面时，选择访问次数最少的页面进行替换。</p><h5 id="“老化算法”-Aging"><a href="#“老化算法”-Aging" class="headerlink" title="“老化算法”(Aging)"></a>“老化算法”(Aging)</h5><p>每个页面有一个计数器，表示页面的优先级。<br>定期对所有页面的计数器进行右移操作，同时将访问的页面的最高位设为1。<br>当需要替换页面时，选择计数器值最小的页面进行替换。（计数时只算R位，R位相同的看W位）</p><p>LRU 页面替换算法在实际系统中能实现吗？为什么？不能实现 需要维护特殊队列，代价较大</p><p>LRU 算法有哪些近似实现算法？NRU、Aging</p><p>Aging 算法要接近 LRU（最近最少使用）算法的效果，需要采取什么措施？①增加寄存器位数，使其存更多历史信息 ②减小时间间隔</p><p>简要描述<strong>最佳页面替换算法</strong>，该算法有何意义？当要调入一页而必须淘汰旧页时，应该淘汰以后不再访问的页，或距现在最长时间后才访问的页（1 分） 此理论算法可用做衡量各种具体算法的标准 （1 分）</p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h4 id="计算-1"><a href="#计算-1" class="headerlink" title="计算"></a>计算</h4><p>. 和 .. 都算inode和目录项</p><p>文件系统的每个 inode 包含直接索引项 12 个和一、二、三级间接索引项各 1 个，物理块大小为 1KB，每个索引项占 4B，每个 inode 占 128B</p><h5 id="该文件系统中-inode-块中文件物理结构信息占多少字节？"><a href="#该文件系统中-inode-块中文件物理结构信息占多少字节？" class="headerlink" title="该文件系统中 inode 块中文件物理结构信息占多少字节？"></a>该文件系统中 inode 块中文件物理结构信息占多少字节？</h5><p>即inode中多重索引表所占空间 &#x3D; 索引项个数 * 索引项大小 &#x3D;  (12+1+1+1) * 4B &#x3D; 60B</p><h5 id="单个文件的理论最大尺寸是多少？"><a href="#单个文件的理论最大尺寸是多少？" class="headerlink" title="单个文件的理论最大尺寸是多少？"></a>单个文件的理论最大尺寸是多少？</h5><p>1KB的块中可以存储1KB&#x2F;4B &#x3D; 256个索引项。单个文件理论最大尺寸  &#x3D; 总共的索引项 * 块大小 &#x3D;（12 + 256 + 256^2  + 256^3）* 1KB</p><p>设某 UNIX 系统，文件系统的每个 inode 包含 10 个直接索引项和一、二、三级间接索引 项各一个，物理块大小为 1KB，每个索引项占 4B。每个目录项占 16B（包含文件名和 inode 号）。inode 区占 5000 个扇区（每扇区 512B）,每个 inode 占 64B，根目录区占 200 个扇 区。</p><h5 id="该文件系统根目录下最多能创建多少个文件或子目录（包括-和-）？"><a href="#该文件系统根目录下最多能创建多少个文件或子目录（包括-和-）？" class="headerlink" title="该文件系统根目录下最多能创建多少个文件或子目录（包括.和..）？"></a>该文件系统根目录下最多能创建多少个文件或子目录（包括.和..）？</h5><p>根目录区大小 &#x2F; 目录项大小 &#x3D; 200*512B &#x2F; 16B &#x3D; 6400</p><h5 id="该文件系统最多能容纳多少个文件或目录？-该文件系统理论上最多能包含多少个文件（包括目录文件）？"><a href="#该文件系统最多能容纳多少个文件或目录？-该文件系统理论上最多能包含多少个文件（包括目录文件）？" class="headerlink" title="该文件系统最多能容纳多少个文件或目录？ &#x2F;   该文件系统理论上最多能包含多少个文件（包括目录文件）？"></a>该文件系统最多能容纳多少个文件或目录？ &#x2F;   该文件系统理论上最多能包含多少个文件（包括目录文件）？</h5><p>inode区大小 &#x2F; inode大小 &#x3D; 5000 * 512B &#x2F; 64B &#x3D; 40000</p><h5 id="如果某个目录下有-610-个文件和-40-个子目录，则该目录文件占多少个物理块？"><a href="#如果某个目录下有-610-个文件和-40-个子目录，则该目录文件占多少个物理块？" class="headerlink" title="如果某个目录下有 610 个文件和 40 个子目录，则该目录文件占多少个物理块？"></a>如果某个目录下有 610 个文件和 40 个子目录，则该目录文件占多少个物理块？</h5><p>目录数 * 目录项大小 &#x3D; (610 + 40) * 16B &#x3D; 10400B   10个物理块（？）</p><p>说明目录文件和普通文件的主要差别？目录文件的内容为目录项，描述目录内容（如父子目录、读写属性等），不可为空；普通文件描述文件数据内容</p><p><strong>目录文件大小</strong> &#x3D; 目录项数 * 目录项大小</p><h5 id="某目录文件-文件占多少磁盘空间"><a href="#某目录文件-文件占多少磁盘空间" class="headerlink" title="某目录文件 &#x2F; 文件占多少磁盘空间"></a>某目录文件 &#x2F; 文件占多少磁盘空间</h5><p>空间 &#x3D; 物理块数 * 块大小 ，刚好超过目录文件 &#x2F; 文件大小即可，注意区分目录文件 &#x2F; 文件</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h5><p>目标文件的另一个名称，指向相同的inode节点。硬链接只能用于单个文件系统，却不能跨越文件系统，可用于文件共享但不能用于目录共享， 其优点是实现简单，访问速度快 </p><h5 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h5><p>一个独立的文件，指向另一个文件或目录的路径名。软链接的优点是能用于链接计算机系统中不同文件系统中的文件，也可用于链接目录，进一步可链接计算机网络中不同机器上的文件，这种方法的缺点是搜索文件路径的开销大，需要额外的空间查找存储路径</p><p>存在一个名为 demo 的目录，该目录下除了.和..，还 存在三个文件 test1.txt、test2.txt 和 test3.txt 三个文件，其中 test1.txt 与 test2.txt 互为硬链接文件，test3.txt 为 test1.txt 的符号链接文件，test1.txt 文件 的内容为 11000 个字符 A。</p><p>demo 目录文件的内容中存在多少个不同的 inode 号？该目录文件的大小？占了多少磁盘空间？</p><p>4个inode号，5个目录项  5*256B &#x3D; 1280B，占据2个物理块  磁盘空间2* 1KB&#x3D; 2KB</p><h5 id="shell-link"><a href="#shell-link" class="headerlink" title="shell link"></a>shell link</h5><p> <code>link(ln) src dst</code>命令的作用是将文件或目录 <code>src</code> 创建一个链接，链接的路径或名称为 <code>dst</code>。</p><p>简述在 Shell 中执行“link &#x2F;test&#x2F;demo.dat &#x2F;demo.dat”时，文件系统的主要操作步骤？</p><p>1 检索目录找到&#x2F;test&#x2F;demo.dat 所指向文件的索引节点编号；</p><p>2 再次检索目录找到 &#x2F;demo.dat 所指文件的父目录文件，并把上一步中获得的索引节点编号与&#x2F;demo.dat 构成一个新目录项，加入到此目录文件中；</p><p>3 将对应索引节点连接计数分量 i_nlink 加一。</p><p>若能成功执行 Shell 命令“ln  &#x2F;users&#x2F;tom&#x2F;a.txt  &#x2F;users&#x2F;ben&#x2F;a.txt ”，则在命令执行过程中需要读取哪些文件的 inode，需要修改哪些文件的 inode？需要新增 inode 吗？需要读取 users、tom、ben、&#x2F;users&#x2F;tom&#x2F;a.txt 文件的 inode， 需要修改&#x2F;users&#x2F;ben&#x2F;a.txt 文件的 inode，不需要新增inode</p><p>Shell 命令“ln -s &#x2F;users&#x2F;tom&#x2F;a.txt &#x2F;users&#x2F;ben&#x2F;a.txt”，与（三）中 Shell 命令有何不同？前一问是硬链接，这里是软链接（符号链接）</p><h4 id="已打开文件表项"><a href="#已打开文件表项" class="headerlink" title="已打开文件表项"></a>已打开文件表项</h4><p>该行代码顺利运行完成后，相应的系统已打开文件表项中引用计数器的值是多少？引用计数器为 3（fork 增加一次，dup 增加一次） （？？）</p><p>画出程序运行过程中用户已打开文件表项、系统已打开文件表项、活动 inode 之间的引用关系示意图？</p><h5 id="用户已打开文件表项"><a href="#用户已打开文件表项" class="headerlink" title="用户已打开文件表项"></a>用户已打开文件表项</h5><p>为每个进程维护的表，每个条目表示一个打开的文件，包含文件描述符、文件偏移量、访问模式等信息。跟踪进程当前打开的文件及其状态，每个进程都有自己的用户已打开文件表，文件描述符是这个表的索引。</p><h5 id="系统已打开文件表项"><a href="#系统已打开文件表项" class="headerlink" title="系统已打开文件表项"></a>系统已打开文件表项</h5><p>全系统范围内维护的表，每个条目表示一个文件，包括文件偏移量、访问模式、引用计数等信息。跟踪系统中所有打开的文件，维护文件的共享状态。引用计数用于记录有多少进程正在使用这个文件。</p><h5 id="活动-inode"><a href="#活动-inode" class="headerlink" title="活动 inode"></a>活动 inode</h5><p>存储在内存中的 inode 表项，表示已打开文件的元数据。包含文件的属性（如文件类型、权限、所有者、文件大小、时间戳等）以及指向文件数据块的指针。</p><p>存储文件的元数据和数据块位置。当文件被打开时，其对应的 inode 被读入内存，并在内存中保持活动状态，直到文件被关闭。</p><h5 id="引用关系示意图"><a href="#引用关系示意图" class="headerlink" title="引用关系示意图"></a>引用关系示意图</h5><p>OS 内核共创建了 4 个用户已打开文件表项，2 个系统已打开文件表项，1 个活动 inode。</p><img src="C:\Users\35458\AppData\Roaming\Typora\typora-user-images\image-20240628221621849.png" alt="image-20240628221621849" style="zoom:50%;" /><h5 id="open"><a href="#open" class="headerlink" title="open"></a>open</h5><p>简要描述 UNIX 系统中 open 系统调用的内核实现过程。（结合文件描述符、用 户已打开文件表、系统已打开文件表、活动 inode 列表等概念）</p><p>通过系统调用陷入内核，查找目标文件对应的 inode 节点，如果未找到该文件，则进行出错处理，如果找到该文件，若它已被其他用户打开，对应 inode 已在活动 inode 表中， 否则创建系统打开文件表 file 结构表项，并在活动 inode 表中分配表项，再用磁盘 inode 填充其内容并用指针进行连接，最后将打开文件的 file 结构的指针安装到用户打开文件表中已分配的表项处，返回文件描述符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = open(&quot;demo.bin&quot;, O_RDONLY)</span><br></pre></td></tr></table></figure><p><strong>fd</strong> ：文件描述符，值一般情况下为 3，含义：用户已打开文件表项索引号。</p><p>文件描述符 <code>0</code> 是标准输入（stdin），文件描述符 <code>1</code> 是标准输出（stdout），文件描述符 <code>2</code> 是标准错误输出（stderr），所以，第一次成功调用 <code>open()</code> 时，通常会分配给文件描述符 <code>3</code></p><p>在不修改上述代码的情况下，此代码运行时该值有没有可能为 0？可以，先 close(0), 再 exec 调用该代码 </p><h4 id="磁盘读取次数"><a href="#磁盘读取次数" class="headerlink" title="磁盘读取次数"></a>磁盘读取次数</h4><p>执行到第 10 行代码 <code>fd = open(&quot;/test/demo.dat&quot;, O_RDONLY)</code> 时，试描述文件系统大致的工作过程，此过程中共计读取几次磁盘？</p><p>共读取 3 次（test 目录 inode、demo.dat 目录项、demo.dat 的 inode）（？）</p><img src="C:\Users\35458\AppData\Roaming\Typora\typora-user-images\image-20240628235419880.png" alt="image-20240628235419880" style="zoom: 67%;" /><p>(二)若普通文件按顺序结构组织，要读文件O的第15块，最少读取磁盘多少次?最多读取磁盘多少次?</p><p>(三)若普通文件按顺序结构组织，要读文件L的第15块，最少启动磁盘多少次?最多启动磁盘多少次?</p><p>(二)及(三)解题分析：</p><p>已知磁盘块长 512B，故供存放目录的空间为：512-12&#x3D;500B，其中，12B为链指针。由于每个目录项占10B，且一个目录下最多存180个下级文件，即180×10&#x3D;1800B，占用磁盘块数&#x3D;1800÷500&#x3D;4 个。由于目录文件采用链接结构，若访问的文件目录在第一磁盘块则需启动磁盘1次，若访问的文件目录在第四磁盘块则需启动磁盘4次。</p><p>(二)若普通文件按顺序结构组织，要读文件O的第15块</p><p>最少启动磁盘次数：从内存根目录找到目录C的目录文件把第一块读入内存(第1次访盘)并查到G，然后，再把目录G的目录文件第一块读入内存(第2次访盘)并查到K。接着，再把目录K的目录文件第一块读入内存(第3次访盘)并查到O。最后，把O的第15块读入内存(第4次访盘)，故最少启动磁盘4次。</p><p>最多启动磁盘次数：读入文件O的第15块最多启动盘次数则是读入每一个目录时均在目录文件的第4块查到下一级目录或文件；这样，除把文件O的第15块读入内存需1次访盘外，由目录C查目录G，由目录G查目录K，由目录K查目录O都各需4次访盘、最多启动磁盘为4x3+1&#x3D;13次。</p><p>(三)若普通文件按顺序结构组织，要读文件L的第15块，最少启动磁盘多少次?最多启动磁盘多少次?</p><p>最少4次，最多10次，因为由 J 查找 L 只用一次</p><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = dup(fd);</span><br></pre></td></tr></table></figure><p><strong>dup</strong> 为文件描述符复制，主要用于输入输出重定向，将文件或管道描述符拷贝至原输入或输出设备文件描述符；（见前面重定向）</p><h5 id="read"><a href="#read" class="headerlink" title="read"></a>read</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rd_count = read(fd, buf, 600)</span><br></pre></td></tr></table></figure><p>从fd中读取最多600个字节放入buf中，返回实际读取的字节数到rd_count</p><p>（物理块大小1KB）试分析第 17 行 代码执行过程中逻辑块到物理块的转换过程，实际会读入多少个数据块？</p><p>17 行代码需要读入 3 个物理块，但由于 21 行代码执行在前，已读入其中的 1 个物理块（被缓存），故 17 行代码实际读入 2 个物理块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lseek(fd, 10245, 0); //移动文件指针至第10245个字节</span><br><span class="line">if (read(fd, buf, 10) &lt;= 0) ...</span><br></pre></td></tr></table></figure><p>简要分析 17 行代码中 read 引发的内核执行过程，此过程中共读取了几个数据块？（给出分析与计算过程）</p><p>（物理块大小1KB）文件指针在 10245 处，读 10 个字节，即读取 10245-10254 的内容，横跨了 2 个物 理块，另外，第 2 个物理块需要通过一次间接索引查找，则额外需要读取 1 个间接索引块。 共计 3 个物理块。？？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">father: read(fd, &amp;buf, 2000) //2000</span><br><span class="line">child: read(fd, &amp;buf, 5000) //4050</span><br></pre></td></tr></table></figure><p>（物理块大小512B）在不考虑磁盘缓冲的情况下，上述代码中父、子进程读文件时，文件系统各读取了几个物理块？ 其中有几个物理块父、子进程都读取了？</p><p>父进程 4 个（1-4），子进程 9 个（4-12）。 有 1 个物理块父、子进程都读取了</p><h5 id="write"><a href="#write" class="headerlink" title="write"></a>write</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open(&quot;test1.txt&quot;, O_RDONLY);</span><br><span class="line">if (write(fd, &quot;1234&quot;, 4) &lt;= 0) ...</span><br></pre></td></tr></table></figure><p>简要叙述 13 行代码中 write 引发的内核执行过程，需结合 open 系统调用；</p><p>根据 write 调用的 fd 参数，查询用户已打开表项，找到对应的系统已打开表项， 根据 open 系统调用的读打开方式判断，写操作非法，返回用户态，给出错误代码。</p><h4 id="不一致性"><a href="#不一致性" class="headerlink" title="不一致性"></a>不一致性</h4><p>对于唯一的块号，状态应该为（空闲，分配）&#x3D; (0, 1) 或 (1, 0) </p><p>在文件系统中，会出现文件系统不一致性的现象，请简要解释这种现象产生的原因以及问题的严重性？</p><p>如果管理空闲块及分配&#x2F;回收程序出现故障，则会导致不一致性错，或丢失盘块(均为 0 的情况)，或破坏信息(如重复分配)</p><p>为解决文件系统的不一致性问题，常采用一个实用程序检查文件系统。在进行了 块的不一致性检查后，得到如下表所示的结果，请解释该文件系统中出现的每一种错误，并 给出处理方法。</p><p>正常情况，空闲块计数与分配块计数应互补。但表中有不一致处，(1, 1)  块 2 重复出现 ， 向系统报告出错。(0, 2) 块 9 分配块重复出现，盘块被分了二次，严重错误，立即报告。(0, 0) 块 11 两组计数中均未出现，报告给系统但影响不大，只是该块被隔离了。(2, 0) 块 15 空闲块出现两次， 可删去一个块 15 号。</p><h1 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h1><p>柱面 – 磁头 – 扇区 （CHS寻址方式）</p><h4 id="移动臂调度算法"><a href="#移动臂调度算法" class="headerlink" title="移动臂调度算法"></a>移动臂调度算法</h4><p>假设磁头当前位置在50，有以下请求（柱面号）：82, 170, 43, 140, 24, 16, 190。</p><h5 id="先来先服务（First-Come-First-Served-FCFS）"><a href="#先来先服务（First-Come-First-Served-FCFS）" class="headerlink" title="先来先服务（First-Come, First-Served, FCFS）"></a>先来先服务（First-Come, First-Served, FCFS）</h5><p>按请求到达的顺序依次处理请求</p><p> 50 -&gt; 82 -&gt; 170 -&gt; 43 -&gt; 140 -&gt; 24 -&gt; 16 -&gt; 190</p><h5 id="最短查找时间优先（Shortest-Seek-Time-First-SSTF）"><a href="#最短查找时间优先（Shortest-Seek-Time-First-SSTF）" class="headerlink" title="最短查找时间优先（Shortest Seek Time First, SSTF）"></a>最短查找时间优先（Shortest Seek Time First, SSTF）</h5><p>优先处理离当前位置最近的请求</p><p>50 -&gt; 43 -&gt; 24 -&gt; 16 -&gt; 82 -&gt; 140 -&gt; 170 -&gt; 190</p><h5 id="电梯调度（LOOK）"><a href="#电梯调度（LOOK）" class="headerlink" title="电梯调度（LOOK）"></a>电梯调度（LOOK）</h5><p>磁头向一个方向移动直到没有更多请求，然后反向。类似于电梯的运行方式，因此得名“电梯调度”</p><p>50 -&gt; 43 -&gt; 24 -&gt; 16 -&gt; 82 -&gt; 140 -&gt; 170 -&gt; 190</p><h5 id="扫描法（SCAN）"><a href="#扫描法（SCAN）" class="headerlink" title="扫描法（SCAN）"></a>扫描法（SCAN）</h5><p>磁头从一个端到另一个端移动，处理所有请求，然后反向移动并处理所有请求。类似于LOOK，但会一直移动到磁盘的物理端。</p><p>50 -&gt; 43 -&gt; 24 -&gt; 16 -&gt; 0 -&gt; 82 -&gt; 140 -&gt; 170 -&gt; 190</p><h5 id="单向扫描（循环扫描）-（C-SCAN）"><a href="#单向扫描（循环扫描）-（C-SCAN）" class="headerlink" title="单向扫描（循环扫描） （C-SCAN）"></a>单向扫描（循环扫描） （C-SCAN）</h5><p>磁头向一个方向移动并处理所有请求，到达磁盘端后直接返回起始端继续处理。类似于SCAN，但不在反向移动时处理请求</p><p>50 -&gt; 82 -&gt; 140 -&gt; 170 -&gt; 190 -&gt; 0 -&gt; 16 -&gt; 24 -&gt; 43</p><h4 id="计算-2"><a href="#计算-2" class="headerlink" title="计算"></a>计算</h4><h5 id="移动臂经历的总柱面数"><a href="#移动臂经历的总柱面数" class="headerlink" title="移动臂经历的总柱面数"></a>移动臂经历的总柱面数</h5><p>eg 100-110-120-129-147-186-46-41-27-10 &#x3D; 86 + 176 &#x3D; 262</p><p>51+69+49+51+95</p><p>设有一个包含了 16 个磁头(编号 0-15)和 120 个柱面(编号 0-119)的磁盘，每磁道扇 区数 200 个(编号 0-199)，每个扇区 512B，磁盘的转速为 7200rpm（转每分钟），相邻柱面间的平均寻道时间为 1ms。试</p><h5 id="该磁盘容量是多少字节？"><a href="#该磁盘容量是多少字节？" class="headerlink" title="该磁盘容量是多少字节？"></a>该磁盘容量是多少字节？</h5><p>16 * 120 * 200 * 512B</p><h5 id="最大理论传输速率是多少字节每秒？"><a href="#最大理论传输速率是多少字节每秒？" class="headerlink" title="最大理论传输速率是多少字节每秒？"></a>最大理论传输速率是多少字节每秒？</h5><p>一直在同一磁道&#x2F;柱面  转到的每个字节都有用，7200 rpm * 200*512B &#x2F;60s </p><h5 id="访问某个扇区的平均循环等待时间是多少？"><a href="#访问某个扇区的平均循环等待时间是多少？" class="headerlink" title="访问某个扇区的平均循环等待时间是多少？"></a>访问某个扇区的平均循环等待时间是多少？</h5><p>磁盘转半周的时间 ( 60s &#x2F;7200rpm ) &#x2F;2</p><p> 设有一个包含了 32 个磁头(编号 0-31)和 200 个柱面(编号 0-199)的磁盘，每磁道扇区数 200 个(编号 0-199)，每个扇区 512B，磁盘的转速为 7200rpm（转每分钟）。</p><h5 id="如果采用位示图方式管理磁盘的空闲扇区，位示图需要占多少扇区？"><a href="#如果采用位示图方式管理磁盘的空闲扇区，位示图需要占多少扇区？" class="headerlink" title="如果采用位示图方式管理磁盘的空闲扇区，位示图需要占多少扇区？"></a>如果采用位示图方式管理磁盘的空闲扇区，位示图需要占多少扇区？</h5><p>位示图用来记录磁盘上每个扇区的分配状态（空闲或已分配），通常以位的形式表示，其中每一位对应一个扇区。</p><p>32 * 200 * 200 bit &#x3D; 160000B &#x2F; 512B &#x3D; 313</p><p>（相邻磁道移动时间1ms）如果磁道号请求队列为：50，90，30，120。对请求队列中的每个磁道需读取1个随机分布的扇区，则读完这4个扇区点共需要多少时间?(给出计算过程)<br>采用 CSCAN 调度算法，访问磁道的顺序为120，30，50，90，则移动磁道长度为0+79+199+30+20+40&#x3D;388，总的<strong>磁道移动时间</strong>为388×1ms&#x3D;388ms。<br>由于转速为6000r&#x2F;m，则平均旋转延迟时间为60&#x2F;(6000x2)×1000ms&#x3D;5ms，总的<strong>扇区旋转时间</strong>为5msx4&#x3D;20ms。<br>由于转速为 6000r&#x2F;m，则读取一个磁道上的一个扇区的平均读取时间为10ms&#x2F;100&#x3D;0.1ms，总的<strong>读取扇区时间</strong>&#x3D;0.1msx4&#x3D;0.4ms。<br>读取上述磁道上的所有4个扇区所花费的总时间&#x3D;388ms+20ms+0.4ms&#x3D;408.4ms。</p><h4 id="简答-1"><a href="#简答-1" class="headerlink" title="简答"></a>简答</h4><p>为提高输入输出效率，是否有必要对相同柱面不同扇区和不同磁头号的请求进行合并操作？（简要说明原因）<br>有必要。柱面间移动耗时较多，将相同柱面请求合并处理，能减少移动臂移动总量。</p><p>若有多个磁盘请求在同一柱面的多个不同扇区上，应采用什么措施提高磁盘访问的效率？<br>归并同一柱面的请求，并对同一柱面请求按<strong>循环排序</strong>的原则（如从小号扇区到大号扇区，或者反之）依次完成请求</p><p>上述哪种移动臂调度算法会导致“饥饿”现象发生？最短查找时间优先调度算法</p><p>实际系统中的磁盘驱动调度算法往往会区分读请求和写请求，请简要讨论其合理性？读写请求的时间容忍度不同，写的容忍度高，因为可以延迟写</p><h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><p>信号量PV</p><p>管程wait signal</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo数学公式渲染</title>
      <link href="/2024/06/hexo%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93/"/>
      <url>/2024/06/hexo%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hexo-next.readthedocs.io/zh-cn/latest/next/advanced/%E9%85%8D%E7%BD%AEMathJax/">配置MathJax - Hexo-NexT</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PS E:\githubPage&gt; npm list</span><br><span class="line">hexo-site@0.0.0 E:\githubPage</span><br><span class="line">+-- hexo-deployer-git@4.0.0</span><br><span class="line">+-- hexo-generator-archive@2.0.0</span><br><span class="line">+-- hexo-generator-category@2.0.0</span><br><span class="line">+-- hexo-generator-index@3.0.0</span><br><span class="line">+-- hexo-generator-tag@2.0.0</span><br><span class="line">+-- hexo-renderer-ejs@2.0.0</span><br><span class="line">+-- hexo-renderer-marked@6.2.0</span><br><span class="line">+-- hexo-renderer-stylus@3.0.1</span><br><span class="line">+-- hexo-server@3.0.0</span><br><span class="line">+-- hexo-theme-landscape@1.0.0</span><br><span class="line">`-- hexo@7.1.1</span><br></pre></td></tr></table></figure><p>卸掉旧渲染</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS E:\githubPage&gt; npm un hexo-renderer-marked</span><br></pre></td></tr></table></figure><p>装pandoc渲染</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS E:\githubPage&gt; npm i hexo-renderer-pandoc</span><br></pre></td></tr></table></figure><p>遇到了vulnerable问题，直接run提示指令（？）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 vulnerabilities (1 moderate, 1 high)</span><br><span class="line">To address all issues, run:</span><br><span class="line">  npm audit fix</span><br></pre></td></tr></table></figure><p>在主题的配置文件里 &#x2F;themes&#x2F;cactus&#x2F;_config.yml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Enable MathJax support for Latex</span><br><span class="line">mathjax:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure><p>尝试一下：</p><p>假如一个事件发生的概率为 $ p $ ，那么可用如下量子态表示：<br>$$<br>\alpha |1⟩ + \beta |0⟩ \quad<br>\text{其中} | \alpha | ^2 &#x3D; p \quad |\beta|^2 &#x3D; 1 - p<br>$$<br>yep</p><hr><p>补充</p><p>xk有存在符号的一天&gt;&lt;</p><p><a href="https://cn.piliapp.com/symbols/there-exists/">存在量词符号（∃） ∃ ∄ (piliapp.com)</a><br>$$<br>∃ x \space \forall y<br>$$<br>好像说_需要转义的 具体没仔细研究 （xk的能用？ $ x_i $</p><p><a href="https://myblackboxrecorder.com/use-math-in-hexo/">在任意的hexo主题支持数学公式 - Gary’s Blog (myblackboxrecorder.com)</a></p><p>还有那个， $  之间需要和内容空开空格</p><p>换行也是没问题的<br>$$<br>\max 5x_1 + 4x_2\<br>2x_1+x_2 \le 100\<br>x_1 \le 30\<br>x_2 \le 60\<br>x_1,x_2 \ge 0<br>$$</p><p>align环境<br>$$<br>\begin{align}<br>&amp;\max \sum_{v\in V}x_v\<br>&amp;x_u +x_v \le 1 \qquad \forall uv \in E \<br>&amp;x_v \in {0,1}<br>\end{align}<br>$$</p><p>to :   $ → $ </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>github仓库初始化</title>
      <link href="/2024/06/github%E4%BB%93%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2024/06/github%E4%BB%93%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>删掉原有git</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf .git</span><br></pre></td></tr></table></figure><p>创建新git</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>假如repo中已有内容 eg <code>README.md</code>，那么先拉过来（合并</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>创建repo仓库xxx</p><p>连接到本地仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:xkxkzzZ/xxxx.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><p>然后即可愉快地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add *</span><br><span class="line">git commit -m &quot;qwq&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>啦</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo配置</title>
      <link href="/2024/06/hexo%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/06/hexo%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h4 id="git"><a href="#git" class="headerlink" title="git"></a>git</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop install main/git</span><br></pre></td></tr></table></figure><p>配置全局git用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;221220074@smail.nju.edu.cn&quot;</span><br><span class="line">git config --global user.name &quot;xkxkzzZ&quot;</span><br></pre></td></tr></table></figure><h4 id="github-ssh"><a href="#github-ssh" class="headerlink" title="github ssh"></a>github ssh</h4><p><a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh">通过 SSH 连接到 GitHub - GitHub 文档</a></p><p>创建并查看ssh密钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C &quot;221220074@smail.nju.edu.cn&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\35458\.ssh&gt; cat .\id_ed25519.pub</span><br><span class="line">ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGkHX/bpSA/M8lYjrsnKHVoo9fsX37s3UgX/fIwImUN1 221220074@smail.nju.edu.cn</span><br></pre></td></tr></table></figure><p>复制添加到github上（ssh和设备绑定）</p><p>settings  -&gt;  SSH and GPG keys  -&gt; New SSH key</p><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><p>（已安装nodejs、git）</p><p>安装hexo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>创建基础网页</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS E:\githubPage&gt; hexo init</span><br></pre></td></tr></table></figure><p>启动本地服务器，这时已经可以在  <code>http://localhost:4000/</code> 看到基础网页了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><h4 id="部署到github上"><a href="#部署到github上" class="headerlink" title="部署到github上"></a>部署到github上</h4><p>在github里新建一个名叫 xkxkzzZ.github.io 的 repository</p><p>全局配置文件 <code>_config.yml</code> 的最下方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:xkxkzzZ/xkxkzzZ.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>下载 hexo-deployer-git </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>hexo deploy 一键部署</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS E:\githubPage&gt; hexo deploy</span><br></pre></td></tr></table></figure><p>这时可以看到github仓库里有文件了</p><p>大家都可以访问 <code>https://xkxkzzz.github.io/</code> 链接看到网页</p><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><p>清除缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo cl</span><br></pre></td></tr></table></figure><p>启动服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>部署到云端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mindspore quantum 配置</title>
      <link href="/2024/06/mindspore%20quantum%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/06/mindspore%20quantum%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h4 id="安装miniconda"><a href="#安装miniconda" class="headerlink" title="安装miniconda"></a>安装miniconda</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop install versions/miniconda3-4.12.0</span><br></pre></td></tr></table></figure><h4 id="安装MindSpore"><a href="#安装MindSpore" class="headerlink" title="安装MindSpore"></a>安装MindSpore</h4><p><a href="https://www.mindspore.cn/install/">MindSpore</a></p><p>2.2.14  &#x2F; CPU &#x2F; Windows-x64 &#x2F; Python3.9 &#x2F; Conda</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda create -c conda-forge -n mindspore_py39 -c conda-forge python=3.9.0</span><br><span class="line">conda activate mindspore_py39</span><br><span class="line">conda install mindspore-cpu -c mindspore -c conda-forge</span><br><span class="line">python -c &quot;import mindspore;mindspore.set_context(device_target=&#x27;CPU&#x27;);mindspore.run_check()&quot;</span><br></pre></td></tr></table></figure><h4 id="安装MindSpore-Quantum"><a href="#安装MindSpore-Quantum" class="headerlink" title="安装MindSpore Quantum"></a>安装MindSpore Quantum</h4><p><a href="https://www.mindspore.cn/mindquantum/docs/zh-CN/master/mindquantum_install.html">MindSpore Quantum</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install mindquantum</span><br><span class="line">python -c &#x27;import mindquantum&#x27;</span><br></pre></td></tr></table></figure><h4 id="安装Jupyter-Notebook"><a href="#安装Jupyter-Notebook" class="headerlink" title="安装Jupyter Notebook"></a>安装Jupyter Notebook</h4><p>但是这样安了一堆包 :water</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyter</span><br><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><p>在vscode中选好相应的环境</p><p>可用后缀名为 <code>.ipynb</code> 的代码块进行可视化</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/02/hello-world/"/>
      <url>/2024/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
